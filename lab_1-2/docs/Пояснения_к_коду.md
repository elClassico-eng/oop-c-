# Пояснения к реализации класса рациональных чисел

## Теоретические основы

**Рациональные числа** — это числа, которые можно представить в виде дроби a/b, где a — целое число (числитель), а b — натуральное число (знаменатель). Множество рациональных чисел обозначается символом ℚ и включает в себя все целые числа (как частный случай, когда знаменатель равен 1).

### Основные свойства рациональных чисел:
1. **Сокращение дробей**: дробь a/b можно привести к несократимому виду, разделив числитель и знаменатель на их наибольший общий делитель (НОД)
2. **Арифметические операции**: над рациональными числами определены операции сложения, вычитания, умножения и деления
3. **Упорядоченность**: рациональные numbers можно сравнивать между собой

## Структура класса RationalNumber

### Поля класса
```csharp
private int numerator;    // Числитель (может быть отрицательным)
private uint denominator; // Знаменатель (всегда положительный)
```

**Обоснование типов:**
- `int` для числителя позволяет хранить отрицательные значения
- `uint` для знаменателя гарантирует положительность и исключает ноль на уровне типа

### Конструкторы

#### 1. Основной конструктор
```csharp
public RationalNumber(int numerator, uint denominator)
```
- Принимает числитель и знаменатель
- Проверяет знаменатель на равенство нулю
- Автоматически сокращает дробь

#### 2. Конструктор с одним параметром
```csharp
public RationalNumber(int numerator) : this(numerator, 1)
```
- Создает рациональное число со знаменателем 1 (целое число)

#### 3. Конструктор по умолчанию
```csharp
public RationalNumber() : this(0, 1)
```
- Создает ноль в виде 0/1

### Алгоритм сокращения дроби

```csharp
private void Reduce()
{
    if (numerator == 0)
    {
        denominator = 1;
        return;
    }
    
    uint gcd = GCD((uint)Math.Abs(numerator), denominator);
    numerator = (int)(numerator / (int)gcd);
    denominator = denominator / gcd;
}
```

**Принцип работы:**
1. Если числитель равен нулю, устанавливаем знаменатель в 1
2. Находим НОД числителя и знаменателя
3. Делим оба числа на НОД

### Алгоритм Евклида для НОД

```csharp
private static uint GCD(uint a, uint b)
{
    while (b != 0)
    {
        uint temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

**Алгоритм Евклида** — эффективный способ нахождения наибольшего общего делителя двух чисел:
- Время выполнения: O(log min(a, b))
- Основан на принципе: НОД(a, b) = НОД(b, a mod b)

### Парсинг строк

```csharp
public static RationalNumber Parse(string str)
{
    Match match = Regex.Match(str, @"^(-?\d+)[:/](\d+)$");
    // Обработка результата...
}
```

**Регулярное выражение:**
- `^(-?\d+)` — числитель (может быть отрицательным)
- `[:/]` — разделитель (двоеточие или слеш)
- `(\d+)$` — знаменатель (положительное число)

### Арифметические операторы

#### Сложение
```csharp
a/b + c/d = (a*d + c*b)/(b*d)
```

#### Вычитание
```csharp
a/b - c/d = (a*d - c*b)/(b*d)
```

#### Умножение
```csharp
a/b * c/d = (a*c)/(b*d)
```

#### Деление
```csharp
a/b ÷ c/d = (a*d)/(b*c)
```

### Операторы сравнения

Для сравнения дробей a/b и c/d используется принцип:
```csharp
a/b < c/d ⟺ a*d < c*b
```

Это избегает деления и работает с целыми числами.

### Специальные элементы

#### Нулевой элемент
```csharp
public static RationalNumber Zero => new RationalNumber(0, 1);
```

#### Единичный элемент
```csharp
public static RationalNumber One => new RationalNumber(1, 1);
```

#### Обратный элемент
```csharp
public RationalNumber Inverse
{
    get
    {
        if (numerator == 0)
            throw new RationalDivisionByZeroException("Невозможно найти обратный элемент для нуля");
        
        if (numerator > 0)
            return new RationalNumber((int)denominator, (uint)numerator);
        else
            return new RationalNumber(-(int)denominator, (uint)(-numerator));
    }
}
```

**Обратный элемент** для числа a/b равен b/a, при условии что a ≠ 0.

### Генерация случайных чисел

```csharp
public static RationalNumber GenerateRandom(RationalNumber min, RationalNumber max)
{
    double minValue = (double)min.numerator / min.denominator;
    double maxValue = (double)max.numerator / max.denominator;
    double randomValue = minValue + (maxValue - minValue) * random.NextDouble();
    
    int randomNumerator = (int)(randomValue * 100);
    uint randomDenominator = 100;
    
    return new RationalNumber(randomNumerator, randomDenominator);
}
```

**Алгоритм:**
1. Преобразуем границы в вещественные числа
2. Генерируем случайное значение в диапазоне
3. Умножаем на 100 и создаем дробь с знаменателем 100
4. Дробь автоматически сокращается в конструкторе

### Обработка исключений

#### InvalidRationalFormatException
- Выбрасывается при неверном формате строки в методе Parse
- Наследует от Exception

#### RationalDivisionByZeroException
- Выбрасывается при попытке создать число с нулевым знаменателем
- Выбрасывается при делении на ноль
- Выбрасывается при получении обратного элемента для нуля

### Интерфейсы

#### IEquatable<RationalNumber>
- Обеспечивает строготипизированное сравнение на равенство
- Повышает производительность по сравнению с Object.Equals

#### IComparable<RationalNumber>
- Позволяет сортировать коллекции рациональных чисел
- Необходим для методов типа Sort, Min, Max

### Переопределение методов Object

#### GetHashCode()
```csharp
public override int GetHashCode()
{
    return HashCode.Combine(numerator, denominator);
}
```
Использует новый метод HashCode.Combine из .NET Core для создания качественного хеш-кода.

#### ToString()
```csharp
public override string ToString()
{
    return $"{numerator}/{denominator}";
}
```
Возвращает строковое представление в формате "числитель/знаменатель".

## Примеры использования

### Создание рациональных чисел
```csharp
var r1 = new RationalNumber(4, 8);  // Результат: 1/2 (автоматическое сокращение)
var r2 = new RationalNumber(5);     // Результат: 5/1
var r3 = new RationalNumber();      // Результат: 0/1
```

### Парсинг строк
```csharp
var r4 = RationalNumber.Parse("3:7");  // Результат: 3/7
var r5 = RationalNumber.Parse("6/9");  // Результат: 2/3 (сокращение)
```

### Арифметические операции
```csharp
var a = new RationalNumber(1, 2);  // 1/2
var b = new RationalNumber(1, 3);  // 1/3

var sum = a + b;        // 5/6
var diff = a - b;       // 1/6  
var product = a * b;    // 1/6
var quotient = a / b;   // 3/2
```

### Сравнение
```csharp
bool isEqual = a == b;    // false
bool isLess = a < b;      // false
bool isGreater = a > b;   // true
```

## Преимущества реализации

1. **Автоматическое сокращение** — дроби всегда хранятся в несократимом виде
2. **Безопасность типов** — использование uint для знаменателя предотвращает многие ошибки
3. **Производительность** — все операции выполняются с целыми числами
4. **Полнота** — реализованы все необходимые операторы и методы
5. **Обработка ошибок** — корректная обработка исключительных ситуаций
6. **Соответствие стандартам** — класс реализует стандартные интерфейсы .NET

## Сложность алгоритмов

- **Конструктор**: O(log min(a, b)) — время работы алгоритма Евклида
- **Арифметические операции**: O(log min(a, b)) — из-за сокращения в конструкторе
- **Сравнение**: O(1) — простое умножение и сравнение
- **Парсинг**: O(n) — обработка строки и регулярное выражение

Данная реализация обеспечивает полную функциональность для работы с рациональными числами в соответствии с математическими принципами и требованиями задания.